#include "stdafx.h"
#include "mmjodb.h"

#include "licensesdialog.h"
#include "dataimportdialog.h"

#include "Database.h"
#include "Strings.h"

#include "FileDialogs.h"
#include "CSVReader.h"

MMJODB::MMJODB(QWidget *parent)
    : QMainWindow(parent)
{
    ui.setupUi(this);
}

MMJODB::~MMJODB()
{}

void MMJODB::open_database(const std::string& filepath, bool allow_create)
{
    try
    {
        auto db = std::make_shared<Database>(filepath, allow_create);
        Database::set_instance(db);
		setWindowTitle(QString::fromStdString(STR_TITLE_MAIN_WINDOW + (" - " + filepath)));
    }
    catch (std::runtime_error& e)
    {
        m_emsg.showMessage(tr(e.what()), tr(STR_INT_ERR_MSG_TYPE_OPEN_DB));
    }
}

bool MMJODB::warn_if_no_db_open(std::shared_ptr<Database> db)
{
    if (db != nullptr)
        return false;

    m_emsg.showMessage(tr(STR_ERR_MSG_NO_DB_OPEN), tr(STR_INT_ERR_MSG_TYPE_NO_DB_OPEN));

    return true;
}

void MMJODB::on_actionOpenDatabase_triggered()
{
    auto filepath = single_file_dialog(this, STR_DIALOG_OPEN_DB_TITLE, STR_DIALOG_OPEN_DB_FILTER, true);
    if (filepath.empty())
		return;

    // TODO: Check if database was generated by older version of MMJODB and needs migration
    //       If so, show dialog to migrate database. If user accepts, create backup and start migration.

    open_database(filepath, false);
}

void MMJODB::on_actionNewDatabase_triggered()
{
    auto filepath = single_file_dialog(this, STR_DIALOG_NEW_DB_TITLE, STR_DIALOG_OPEN_DB_FILTER, false);
    if (filepath.empty())
		return;

    open_database(filepath, true);

    // TODO: Create necessary tables
}

void MMJODB::on_actionShowDetails_triggered()
{
    auto db = Database::get_instance();
    if (warn_if_no_db_open(db))
        return;

	// TODO: Implement database details dialog
    m_emsg.showMessage(
        tr(STR_ERR_MSG_NOT_IMPLEMENTED),
        tr(STR_INT_ERR_MSG_TYPE_NOT_IMPLEMENTED)
    );
}

void MMJODB::on_actionImportData_triggered()
{
    auto db = Database::get_instance();
    if (warn_if_no_db_open(db))
        return;

    DataImportDialog import_dialog(this);
    import_dialog.exec();
}

void MMJODB::on_actionImportImages_triggered()
{
    auto db = Database::get_instance();
    if (warn_if_no_db_open(db))
        return;


	// TODO: Implement image import functionality
    m_emsg.showMessage(
        tr(STR_ERR_MSG_NOT_IMPLEMENTED),
        tr(STR_INT_ERR_MSG_TYPE_NOT_IMPLEMENTED)
	);
}

void MMJODB::on_actionShowLicenses_triggered()
{
    auto dialog = new LicensesDialog(this);
    dialog->exec();
}

void MMJODB::on_actionOpenWebsite_triggered()
{
    QDesktopServices::openUrl(QUrl(STR_URL_GITHUB_PAGES_MMJODB));
}

void MMJODB::on_buttonRunSQLQuery_clicked()
{
    auto db = Database::get_instance();
    if (warn_if_no_db_open(db))
        return;

    auto sql_stmt_str = ui.textEditSQLQuery->toPlainText().toStdString();

    auto query = db->make_query(sql_stmt_str);

    ui.labelSQLError->clear();
    ui.tabSQLOutput->clear();

    int num_tabs = 0;

    QTableWidget* curr_table = nullptr;

    auto table_callback = [&](const std::vector<std::pair<std::string, DBRow::Column::Type>>& columns)
        {
            QWidget* new_tab = nullptr;

            if (columns.empty())
            {
                QLabel* label = new QLabel(
                    tr(STR_INFO_NO_DATA_RETRIEVED)
				);

				label->setAlignment(Qt::AlignCenter);

                new_tab = label;
            }
            else
            {
                curr_table = new QTableWidget();
                curr_table->setColumnCount((int)columns.size());

                // Set table header labels
                QStringList col_names_qstr;
                col_names_qstr.reserve(columns.size());
                for (const auto& column : columns)
                {
                    std::string name = column.first; // +" (" + column_type_to_string(column.second) + ")";
                    col_names_qstr.append(QString::fromStdString(name));
                }

                curr_table->setHorizontalHeaderLabels(col_names_qstr);
                curr_table->setHorizontalScrollMode(QAbstractItemView::ScrollMode::ScrollPerPixel);

                new_tab = curr_table;
            }
            // Create new tab for SQL output table
			std::string tab_name = STR_SQL_OUTPUT_TAB_NAME_PREFIX + std::to_string(++num_tabs);
            ui.tabSQLOutput->addTab(new_tab, QString::fromStdString(tab_name));

            return true;
        };

    auto row_callback = [&](const DBRow& row)
        {
			// Add row to table
			int row_index = curr_table->rowCount();
            curr_table->insertRow(row_index);

            for (int i = 0; i < row.get_col_cnt(); ++i)
            {
                auto col = row.get_col(i, DBRow::Column::Type::Text);

                std::string value;
                if (col.value().get_type() == DBRow::Column::Type::Null)
                    value = "<NULL>";
                else
					value = col.value().get_text();

                auto item = new QTableWidgetItem(QString::fromStdString(value));
                item->setFlags(item->flags() & ~Qt::ItemIsEditable);
                curr_table->setItem(row_index, i, item);
            }
            return true;
        };

    if (query.execute(row_callback, table_callback))
        ui.labelSQLError->setText(
            QString::fromStdString(
                STR_SQL_ERROR_PREFIX + query.get_err_msg()
            )
        );
}